\newacronym{bfs}{BFS}{Breadth-First Search}
\newacronym{dfs}{DFS}{Depth-First Search}
\newacronym{gbfs}{GBFS}{Greedy Best-First Search}
\newacronym{as}{A*}{A* Search}
\newacronym{iddfs}{IDDFS}{Iterative-Deepening Depth-First Search}
\newacronym{ida}{IDA*}{Iterative-Deepening A* Search}
\newacronym{fifo}{FIFO}{First-In, First-Out queue structure}
\newacronym{lifo}{LIFO}{Last-In, First-Out queue structure}

\newglossaryentry{graph}
{
	name=graph,
	description={An abstract data type, representing either a \gls{directed} or \gls{undirected} graph structure, that contains a set of \glspl{vertex} with pairs of these connected by \glspl{edge}. Each edge may or may not be weighted by a given cost function}
}

\newglossaryentry{vertex}
{
	name=vertex,
	description={Terminology used in \gls{graph} data types. Synonymous with the concept of a \gls{node}},
	plural=vertices
}

\newglossaryentry{edge}
{
	name=edge,
	description={Terminology used in \gls{graph} data types. Defines a link or path between a specific pair of \glspl{vertex}, which may or may not be weighted with a given cost}
}

\newglossaryentry{directed}
{
	name={directed graph},
	description={A type of \gls{graph} where each \gls{edge} also has a \textit{direction}, meaning they can only be traversed from \glspl{vertex} with edges pointing away from them}
}

\newglossaryentry{undirected}
{
	name={directed graph},
	description={A type of \gls{graph} where each \gls{edge} has no \textit{direction}, meaning they can be traversed from either end}
}

\newglossaryentry{root}
{
	name={root node},
	description={The node at the start of a tree data structure from which all children extend, usually denoted by removing its parent reference, i.e. making it equivalent to null}
}

\newglossaryentry{tree}
{
	name=tree,
	description={An abstract data type that represents a hierarchy of \glspl{node} extending from a single \gls{root} node}
}

\newglossaryentry{node}
{
	name=node,
	description={A generalized element of different types data structures that represents a single value or object of interest. It will usually contain a reference or pointer to it's parent or adjacent nodes}
}

\newglossaryentry{leaf}
{
	name=leaf,
	description={A \gls{node} in a \gls{tree} data structure that has no children, i.e. a terminal state}
}

\newglossaryentry{branch}
{
	name=branch,
	description={In a \gls{tree} data structure, a branch is a \gls{node} with \textit{at least} one child}
}

\newglossaryentry{pathcost}
{
	name={path cost},
	description={Path cost, denoted as $g(n)$ where $n$ is a node in a search tree, is the cost of getting from the root node in a search tree to $n$}
}

\newglossaryentry{heuristic}
{
	name={heuristic function},
	description={A function, denoted as $h(n)$ which returns an \textit{estimation} of the quality of a specific node $n$}
}

\newglossaryentry{evaluation}
{
	name={evaluation function},
	description={A function, denoted as $f(n)$ which returns an evaluation of the estimated cost of a specific node $n$, calculated using either $h(n)$ or some combination of both $h(n)$ \textbf{and} $g(n)$}
}

\newglossaryentry{uninformed}
{
	name={uninformed search},
	description={A search algorithm that has no information of the search space other than the ability to detect the type of node encountered (i.e. start, end, wall)}
}

\newglossaryentry{informed}
{
	name={informed search},
	description={Synonymous with \textit{heuristic search}. A search algorithm that has domain-specific knowledge of the search space, such as the distance from the start or end states, that define a \gls{heuristic} function $f(n)$ for evaluating the quality of a given node $n$}
}

\newglossaryentry{environment}
{
	name={task environment},
	description={In the context of a search problem, the \textit{task environment} is the space and problem for which an agent attempts to find a solution}
}

\newglossaryentry{rnp}
{
	name={RNP},
	long={Robot Navigation Problem (RNP)},
	description={The \textbf{Robot Navigation Problem (RNP)} is a \Gls{environment} in which a simulated robot attempts to find an optimal route to a given \textit{goal} \gls{node} in an $N \times M$ grid of nodes, where $N=width$, $M=height$ and both are non-zero}
}

\newglossaryentry{frontier}
{
	name=frontier,
	description={a container that stores all encountered but unexpanded nodes so far. The data structure used to implement the frontier is specific to each algorithm}
}

\newglossaryentry{complete}
{
	name=completene,
	plural=completeness,
	description={A search algorithm is called \textbf{complete} when it's guaranteed to find a solution as long as one exists}
}

\newglossaryentry{optimal}
{
	name=optimal,
	plural=optimality,
	description={A search algorithm is called \textbf{optimal} when it is guaranteed to find the solution with the lowest path cost that exists each time it's executed}
}
