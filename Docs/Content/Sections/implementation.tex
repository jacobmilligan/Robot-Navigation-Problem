\section{Implementation} % (fold)
\label{sec:implementation}

\subsection{Search Methods} % (fold)
\label{sub:search_methods}
Each search method is a derived form of the base \mintinline[bgcolor=codebg]{cpp}{SearchMethod} class, each implementing the \mintinline[bgcolor=codebg]{cpp}{search()} and \mintinline[bgcolor=codebg]{cpp}{get_child()} methods.
% subsection search_methods (end)

\paragraph{BFS} % (fold)
\label{par:bfs}
BFS was implemented iteratively, using a FIFO frontier, its pseudocode shown below.

\begin{breakablealgorithm}
	\caption{BFS}
	\begin{algorithmic}[1]
		\Procedure{search}{$env$ - a problem environment}
			\State $n \gets$ starting state, $explored \gets$ \{\}, $frontier \gets$ empty FIFO queue
			\If {$n = goal$}
				\State return solution
			\EndIf
			\State add $n$ to $frontier$
			\While{$frontier \neq empty$}
				\State $n \gets$ first node in frontier
				\ForAll{valid child $c$ with action $a$ in $env$}
					\If{not explored}
						\State add $c$ to explored set
						\If{$c=goal$}
							\State return solution
						\EndIf
						\State add to frontier
					\EndIf
				\EndFor
			\EndWhile
			\State return no solution found
		\EndProcedure
	\end{algorithmic}
\end{breakablealgorithm}
% paragraph bfs (end)

\paragraph{DFS} % (fold)
\label{par:dfs}
DFS is implemented in a very similar way to the pseudocode outlined above for BFS, however it uses a LIFO queue as it's frontier instead of a FIFO queue.
% paragraph dfs (end)

\paragraph{GBFS and A*} % (fold)
\label{par:gbfs_and_a_}
Once again, GBFS and A* are both implemented similarily to BFS and DFS but using a a priority queue as their frontier. Furthermore, when getting a valid child from the environment, both add their heuristic cost to the child node before adding it to the frontier, to do this they override \mintinline[bgcolor=codebg]{cpp}{SearchMethods}'s \mintinline[bgcolor=codebg]{cpp}{get_child()} method. GBFS will simply assign as its $f$ cost the distance to the goal using one of the distance functions outlined in section~\ref{sub:as}, while A* will sum both the distance and the child nodes parent $f$ value.
% paragraph gbfs_and_a_ (end)

\paragraph{IDDFS} % (fold)
\label{par:iddfs}
IDDFS is implemented recursively in the following manner using a specialized results struct containing a cutoff value and the solution if it exists.

\begin{breakablealgorithm}
\caption{IDDFS implementation pseudocode}
\begin{algorithmic}[1]
	\Procedure{search}{$env$ - a problem environment}
		\State $results \gets$ empty results set, $\ell \gets 1$
		\While{$results.cutoff$}
			\State $results \gets$ $depth\_limited\_search(env,\ \ell)$
			\State $\ell \gets \ell + 1$
		\EndWhile
		\State return $results$
	\EndProcedure

	\State

	\Procedure{depth\_limited\_search}{$env$ - a problem environment, $\ell$}
		\State $n \gets$ starting node in $env$
		\State return $\mathit{recursive\_dls}(n,\ env,\ \ell)$
	\EndProcedure

	\State

	\Procedure{recursive\_dls}{$env$ - a problem environment, $n$ - a node. $d$ - the current depth}
		\State Add $n$ to explored set
		\If{$n=goal$} return solution \EndIf
		\If{$d < 1$} return cutoff \EndIf
		\State $\mathit{cutoff\_occurred} \gets false$
		\State $results \gets$ empty results set
		\ForAll{children $c$ of $n$ with valid actions $a$ in $env$}
			\If{$c$ not in explored set}
				\State $results \gets \mathit{recursive\_dls}(c,\ env,\ d-1)$
				\If{$results.cutoff$}
					$\mathit{cutoff\_occurred} \gets true$
				\ElsIf{solution found in $results$}
					return $results$
				\EndIf
			\EndIf
		\EndFor
		\State return $\mathit{cutoff\_occurred}$
	\EndProcedure


\end{algorithmic}
\end{breakablealgorithm}
% paragraph iddfs (end)

\paragraph{IDA*} % (fold)
\label{par:ida_}
IDA* is implemented almost identically to to IDDFS, however it keeps a temporary map of the current path to ensure that nodes in the same path aren't repeated, alongside using the last encountered $f$ value higher than the current limit as the cutoff.
% paragraph ida_ (end)

\subsection{Frontier} % (fold)
\label{sub:frontier}
Each search method utilized a different frontier container type. The interface for this is provided via the \mintinline[bgcolor=codebg]{cpp}{Frontier<T>} template type which has FIFO (\mintinline[bgcolor=codebg]{cpp}{Frontier<std::queue>}), LIFO (\mintinline[bgcolor=codebg]{cpp}{Frontier<std::vector>}), and Priority Queue (\mintinline[bgcolor=codebg]{cpp}{Frontier<std::priority_queue>}) specializations whilst providing the same interface for all types.
% subsection frontier (end)

\subsection{Explored Set} % (fold)
\label{sub:exploredset}
The \mintinline[bgcolor=codebg]{cpp}{ExploredSet} class provides an interface for adding and querying the nodes so far expanded for each search algorithm, this is implemented using an \mintinline[bgcolor=codebg]{cpp}{std::unordered_map}. The explored set also contains an \mintinline[bgcolor=codebg]{cpp}{std::vector} of all the operations that occurred during the search algorithm for use in the visualizer (see~\ref{sub:visualizer}) for displaying the search tree as it was operated on in order.
% subsection exploredset (end)

\subsection{Environment} % (fold)
\label{sub:environment}
Finally, the environment class defines valid actions and generates new child nodes based on the current \textit{state} - (a point in the grid). It also defines a \textit{goal test} for determining whether a given state is the goal.
% subsection environment (end)

% section implementation (end)
